/* CityDefaultInitialization:
 * 
 * A class containing two static methods related to travel in City Mode.
 * 
 * Method stationsFileToArrayList reads from CityStationsText.txt to create a
 * list of stations and connect the stations along the rows and columns
 * indicated in the file.
 * 
 * Method implementTravel creates an array of three possible Routes between two
 * stations in the city.
 * 
 * 
 * City has 5+8=13 rows/columns like this:
 *    --1---9--17--25--33--
 *      |   |   |   |   |
 *    --2--10--18--26--34--
 *      |   |   |   |   |
 *    --3--11--19--27--35--
 *      |   |   |	 |   |
 *     ... ... ... ... ...
 *      |   |   |	 |	 |
 *    --8--16--24--32--40--
 * Current constraints around Atlanta:
 * NW) 33.883594, -84.548232
 * SW) 33.651294, -84.548232
 * SE) 33.651294, -84.273736
 * NE) 33.883594, -84.273736
 * Square Characteristics: ~256 square miles, ~16 mile edges, max length of a
 * bus route is ~23 miles assuming straight line from SE to NE
 */

import java.util.ArrayList;
import java.io.*;

public class CityDefaultInitialization
{
	public static ArrayList<BusStation> stationsFileToArrayList() throws Exception
	// Returns a list of BusStations reads from CityStationsText.txt and
	// connected along the rows and columns indicated in the file.
    {
    	File file = new File( "CityStationsText.txt" );
    	BufferedReader br = new BufferedReader( new FileReader( file ) );
    	ArrayList<BusStation> stations = new ArrayList<BusStation>();
    	String line = br.readLine();
    	
    	// First part of file, stations:
    	
    	while( !line.isEmpty() ) // Until line.equals("")
    	{
    		String[] splitLine = line.split( ", " );
    	    // Should have 3 elements corresponding to BusStation's 3 fields
    		stations.add( new BusStation(
    			Double.parseDouble( splitLine[0] ),
    			Double.parseDouble( splitLine[1] ),
    			splitLine[2].replaceAll( "\"", "" ) ) );
    		line = br.readLine();
    	}
    	line = br.readLine();
    	
    	// Second part of file, connections:
    	
    	while( line != null )
    	{
    		String[] splitLine = line.split( " " );
    		// Each of these lines represents one of the 13 rows/columns in the
    		// city. Stations in a row/column are connected 0th to 1st, 1st to
    		// 2nd, ..., next-to-last to last.
    		for( int i = 0; i < (splitLine.length - 1); ++i )
    		{
    			int index0 = Integer.parseInt( splitLine[  i  ] );
    			int index1 = Integer.parseInt( splitLine[ i+1 ] );
    			stations.get( index0 ).connect( stations.get( index1 ) );
    			stations.get( index1 ).connect( stations.get( index0 ) );
    		}
    		line = br.readLine();
    	}
    	br.close();
    	return stations;
    }
	
	public static Route[] implementTravel(int begin, int end) throws Exception
	// This method generates 3 Routes between the start station at index begin
    // and the destination station at index end. This method may not succeed in
    // finding all, some, or any Routes, in which cases it still returns an
    // array of length 3 but with nulls for Routes that cannot be found. The
    // first Route (if it exists) is the shortest Route generated by Dijkstra's
    // Algorithm, and the second and third Routes (if they exist) are semi-
    // random Routes with the constraint that each leg takes the person closer
    // to the destination.
    // 
    // LongDistTravel.implementTravel is almost exactly the same as this method!
	// That method reads from the LongDistStationsDatabase, though, so we can't
    // use it for City Mode. Instead we read from CityStationsText.txt.
    // 
    // This method's arguments begin and end are indices numbered from 1, not 0.
    {
		ArrayList<BusStation> stations = stationsFileToArrayList();
        
        int s = begin - 1; // Convert to a 0-based index
        if( s < 0 || s > 39 )
        	throw new Exception();
        
        int d = end - 1;   // Convert to a 0-based index
        if( d < 0 || d > 39 )
        	throw new Exception();
        
        BusStation start = stations.get(s);
        BusStation dest  = stations.get(d);
        
        ArrayList<DijkstraStation> dStations =
        		DijkstraStation.busStationsToDijkstraStations( stations, start );
        
        // Find first, best Route:
        
        Route bestRoute = DijkstraStation.dijkstraRoute( dStations, dest, false );
        
        // Find second, semirandom Route, if possible:
        
        final int MAX_TRIES = 8;
            // Number of tries to find a new Route different from previous ones
        int numTries = 0;
            // Number of tries used
        Route secondRoute;
        while( true ) // Until broken
        {
        	if( numTries >= MAX_TRIES )
        		return new Route[] { bestRoute, null, null };
        	secondRoute = DijkstraStation.dijkstraRoute( dStations, dest, true );
        	if( !bestRoute.equals( secondRoute ) )
        		break; // secondRoute found!
        	++numTries;
        }
        
        // Find third, semirandom Route, if possible:
        
        numTries = 0;
        Route thirdRoute;
        while( true ) // Until broken
        {
        	if( numTries >= MAX_TRIES )
        		return new Route[] { bestRoute, secondRoute, null };
        	thirdRoute = DijkstraStation.dijkstraRoute( dStations, dest, true );
        	if( !bestRoute.equals( thirdRoute ) && !secondRoute.equals( thirdRoute ) )
        		break; // thirdRoute found!
        	++numTries;
        }
        
        return new Route[] { bestRoute, secondRoute, thirdRoute };
    }
}